        implicit real *8 (a-h,o-z)
        dimension xstria(5),ystria(5),zs(2,10000),
     1      xs(10 000),ys(10 000),whts(10 000),pols(5000 000),
     2      amatr(2000 000),vert1(2),vert2(2),vert3(2),
     3      w(2000 000),pols2(20 000),z2(10),uu(1000 000),
     4      vv(1000 000),arr(1000 000),pols22(20 000),
     5      diffs(20 000),s(200 000)
c 
        call prini(6,13)
C 
C       SET ALL PARAMETERS
C 
        PRINT *, 'ENTER mmax'
        READ *,mmax
        CALL PRINf('mmax=*',mmax,1 )
c 
        n=mmax+1
c 
c       construct the standard triangle
c 
        done=1
        xstria(1)=0
        xstria(2)=-1
        xstria(3)=1
        xstria(4)=0
c 
        ystria(1)=2/sqrt(done*3)
        ystria(2)=-1/sqrt(done*3)
        ystria(3)=-1/sqrt(done*3)
        ystria(4)=2/sqrt(done*3)
  
  
  
        iw=21
        call lotaplot(iw,xstria,ystria,4,'standard triangle*')
  
c 
c       construct stupid tensor product nodes
c 
        vert1(1)=xstria(1)
        vert2(1)=xstria(2)
        vert3(1)=xstria(3)
c 
        vert1(2)=ystria(1)
        vert2(2)=ystria(2)
        vert3(2)=ystria(3)
c 
        ifinit=1
        call triagauc(n,vert1,vert2,vert3,zs,
     1      whts,ifinit,w)
  
        kk=n**2
c 
        do 1200 i=1,kk
c 
        xs(i)=zs(1,i)
        ys(i)=zs(2,i)
 1200 continue
c 
        iw=22
        call lotaplot2(iw,xstria,ystria,4,xs,ys,kk,
     1         'standard triangle withwandzura nodes*')
c 
c       construct the orthogonal polynomials
c 
c 
        eps=1.0d-13
cccc        eps=1.0d-30
  
        itest=100
        itest=3
c 
  
        iw=17
        call orthopol(iw,zs,whts,kk,pols,amatr,eps,mmax,
     1      pols2,uu,vv,itest,arr,mmm,s,mtot)
c 
        call prinf('after orthopol, mmm=*',mmm,1)
  
        nvals=(mmax+1)*(mmax+2)/2
c 
c       evaluate the polynomials at the test point using the
c       stored coefficients, and compare them to those produced
c       by the subroutine
c 
        z2(1)=zs(1,itest)
        z2(2)=zs(2,itest)
        call orthoeva(mmax,z2,pols22,arr,w)
c 
        do 2200 i=1,nvals
c 
        diffs(i)=pols22(i)-pols2(i)
 2200 continue
  
        call prin2('and diffs=*',diffs,nvals)
        call prinf('and mtot=*',mtot,1)
  
  
        stop
        end
c 
c 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c        This is the end of the debuging code and the beginning of the
c        code for the creation of the orthogonal polynomials on the
c        standard triangle.
c 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c 
c        This code has 6 user-callable subroutines: orthopol, orthoeva,
c        ortretr, ortconv, ortread.
c 
c   orthopol generates the coefficients that are to be used later
c        for the construction of orthogonal polynomials on the
c        "standard" tringle with the vertices
c 
c       (0,2/sqrt(3)), (-1,sqrt(1/sqrt(3)), (1,sqrt(1/sqrt(3)),
c 
c        and stores them on disk as formatted data. This format is chosen
c        for portability. However, it is bulky and (more importantly)
c        causes a slight delay when the data are to be read.
c 
c   orthoeva uses the coefficients generated by the subroutine orthopol
c        to evaluate the orthogonal polynomials at user-specified points
c        in R^2
c 
c   orthoeva3 is identical to orthoeva, except that it also produces the
c        detrivatives of orthogonal polynomials with respect to x,y.
c 
c   ortretr retrieves from disk the data stored there by orthopol
c 
c   ortconv reads from disk the data stored there by orthopol, and stores
c        them on a different FORTRAN unit as unformatted data, to be read
c        by the subroutine ortread
c 
c   ortread - reads from disk the data stored there by ortconv. Since the
c        data are unformatted, the process is essentially instantaneous.
c 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c 
c 
c 
c 
c 
        subroutine orthoeva3(mmax,z2,pols2,dersx,dersy,arr,w)
        implicit real *8 (a-h,o-z)
        save
        dimension pols2(1),z2(2),www(3),arr(1),w(1),dersx(1),dersy(1)
c 
c       this subroutine evaluates at the user-supplied point z2
c       a collection of polynomials (of x,y) orthogonal on the
c       standard triangle, together with their derivatives with respect
c       to x,y. The "standard" triangle is the triangle with the
c       vertices
c 
c       (0,2/sqrt(3)), (-1,sqrt(1/sqrt(3)), (1,sqrt(1/sqrt(3)).       (1)
c 
c       The polynomials evaluated by this subroutine are all
c       orthogonal polynomials up to order mmax, arranged in the
c       increasing order. Within the polynomials of the same order,
c       both the choice of the basis and the ordering of the elements
c       within that basis are somewhat (but not quite) arbitrary.
c 
c                   Input parameters:
c 
c  mmax - the maximum order to which the polynomials are to be evaluated;
c       must not exceed that generated by the preceding call to the
c       subroutine orthopol that generated the coefficients arr.
c  z2 - the location in R^2 where the polynomials are to be evaluated;
c       normally, expected to be inside (including boundary) the t
c       standard triangle (1) above.
c  arr - the array generated previously by the subroutine orthopol
c 
c                   Output parameters:
c 
c  pols2 - the orthogonal polynomials evaluated at the point z2
c       ( (mmax+1)*(mmax+2)/2 of them things)
c  dersx - the derivatives with respect to x of the polynomials
c       returned in array pols2
c  dersy - the derivatives with respect to y of the polynomials
c       returned in array pols2
c 
c 
c       . . . allocate memory for the work arrays
c 
        m=mmax
        ivv=1
        lvv=(mmax+1)*mmax*3+100
c 
        iavect=ivv+lvv
        lavect=m*3+10
c 
        ibvect=iavect+lavect
        lbvect=m*3+10
c 
        icvect=ibvect+lbvect
        lcvect=m*3+10
c 
        iwww=icvect+lcvect
        lwww=m+2
c 
c       initialize the recursion
c 
        mmm=0
c 
        pols2(1)=1
c 
        mmm=mmm+1
        d=arr(mmm)
        pols2(1)=pols2(1)*d
c 
        done=1
        d34=3*done/4
        d34=sqrt(d34)
c 
        pols2(2)=pols2(1)*z2(2)
        pols2(3)=pols2(1)*(z2(1)*d34-z2(2)/2)
        pols2(4)=pols2(1)*(-z2(1)*d34-z2(2)/2)
c 
c 
        dersx(1)=0
        dersx(2)=0
        dersx(3)=d34*pols2(1)
        dersx(4)=-d34*pols2(1)
c 
c 
        dersy(1)=0
        dersy(2)=pols2(1)
        dersy(3)=-pols2(1)/2
        dersy(4)=-pols2(1)/2
c 
        mmm=mmm+1
        call orthmove(arr(mmm),w(ivv),6)
        call ortmatve(w(ivv),pols2(2),2,3,www)
c 
        pols2(2)=www(1)
        pols2(3)=www(2)
c 
        call ortmatve(w(ivv),dersx(2),2,3,www)
c 
        dersx(2)=www(1)
        dersx(3)=www(2)
c 
c 
        call ortmatve(w(ivv),dersy(2),2,3,www)
c 
        dersy(2)=www(1)
        dersy(3)=www(2)
c 
        mmm=mmm+6
c 
c       one order after another, construct all the requested
c       orthogonal polynomials of z2
c 
        imm2=1
        imm1=2
c 
        do 3000 m=2,mmax
c 
        imm=imm1+m
c 
        call orevnext3(m,pols2(imm2),pols2(imm1),pols2(imm),
     1      z2,arr,mmm,w(ivv),w(iwww),w(iavect),
     2      dersx(imm2),dersx(imm1),dersx(imm),
     3      dersy(imm2),dersy(imm1),dersy(imm),
     4      w(ibvect),w(icvect) )
c 
        imm2=imm1
        imm1=imm
 3000 continue
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine orevnext3(m,pols2mm2,pols2mm1,pols2m,z2,
     1      arr,mmm,vv,www,avect,
     2      dersxmm2,dersxmm1,dersxm,
     3      dersymm2,dersymm1,dersym,bvect,cvect)
        implicit real *8 (a-h,o-z)
        save
        dimension vv(1),pols2mm2(m-1),pols2mm1(m),pols2m(m+1),
     1      z2(2),www(1),arr(1),avect(1),dersxmm2(1),dersxmm1(1),
     2      dersxm(1),bvect(1),cvect(1),dersymm2(1),
     3      dersymm1(1),dersym(1)
c 
c        multiply all orthogonal polynomials of the preceding
c        order by the three linear combinations of x, y
c 
        done=1
        d34=3*done/4
        d34=sqrt(d34)
c 
        ii=0
        do 2000 i=1,m
c 
        ii=ii+1
        avect(ii)=pols2mm1(i)*z2(2)
        bvect(ii)=dersxmm1(i)*z2(2)
        cvect(ii)=dersymm1(i)*z2(2)+pols2mm1(i)
c 
c 
        ii=ii+1
        avect(ii)=pols2mm1(i)*(z2(1)*d34-z2(2)/2)
        bvect(ii)=dersxmm1(i)*(z2(1)*d34-z2(2)/2)+
     1            d34*pols2mm1(i)
  
        cvect(ii)=dersymm1(i)*(z2(1)*d34-z2(2)/2)-
     1            pols2mm1(i)/2
c 
c 
        ii=ii+1
        avect(ii)=pols2mm1(i)*(-z2(1)*d34-z2(2)/2)
        bvect(ii)=dersxmm1(i)*(-z2(1)*d34-z2(2)/2)-
     1            d34*pols2mm1(i)
        cvect(ii)=dersymm1(i)*(-z2(1)*d34-z2(2)/2)-
     1            pols2mm1(i)/2
c 
 2000 continue
c 
c       orthogonalize the new polynomials to those in psmm1
c 
        do 2600 i=1,m
c 
        do 2400 j=1,m*3
c 
        mmm=mmm+1
        d=arr(mmm)
        avect(j)=avect(j)-pols2mm1(i)*d
        bvect(j)=bvect(j)-dersxmm1(i)*d
        cvect(j)=cvect(j)-dersymm1(i)*d
c 
 2400 continue
 2600 continue
c 
c       orthogonalize the new polynomials to those in psmm2
c 
        do 3600 i=1,m-1
c 
        do 3400 j=1,m*3
c 
        mmm=mmm+1
        d=arr(mmm)
        avect(j)=avect(j)-pols2mm2(i)*d
        bvect(j)=bvect(j)-dersxmm2(i)*d
        cvect(j)=cvect(j)-dersymm2(i)*d
 3400 continue
 3600 continue
c 
        mmm=mmm+1
        jj=(m+1)*m*3
        call orthmove(arr(mmm),vv,jj)
c 
        call ortmatve(vv,avect,m+1,m*3,pols2m)
        call ortmatve(vv,bvect,m+1,m*3,dersxm)
        call ortmatve(vv,cvect,m+1,m*3,dersym)
c 
        mmm=mmm+jj
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine orthoeva(mmax,z2,pols2,arr,w)
        implicit real *8 (a-h,o-z)
        save
        dimension pols2(1),z2(2),www(3),arr(1),w(1)
c 
c       this subroutine evaluates at the user-supplied point z2
c       a collections of polynomials (of x,y) orthogonal on the
c       standard triangle, i.e. the triangle with the vertices
c 
c       (0,2/sqrt(3)), (-1,sqrt(1/sqrt(3)), (1,sqrt(1/sqrt(3)).       (1)
c 
c       The polynomials evaluates by this subroutine are all
c       orthogonal polynomials up to order mmax, arranged in the
c       increasing order. Within the polynomials of the same order,
c       both the choice of the basis and the ordering of the elements
c       within that basis are somewhat (but not quite) arbitrary.
c 
c                   Input parameters:
c 
c  mmax - the maximum order to which the polynomials are to be evaluated;
c       must not exceed that generated by the preceding call to the
c       subroutine orthopol that generated the coefficients arr.
c  z2 - the location in R^2 where the polynomials are to be evaluated;
c       normally, expected to be inside (including boundary) the t
c       standard triangle (1) above.
c  arr - the array generated previously by the subroutine orthopol
c 
c                   Output parameters:
c 
c  pols2 - the orthogonal polynomials evaluated at the point z2
c       ( (mmax+1)*(mmax+2)/2 of them things)
c 
c       . . . allocate memory for the work arrays
c 
        m=mmax
        ivv=1
        lvv=(mmax+1)*mmax*3+100
c 
        iavect=ivv+lvv
        lavect=m*3+10
c 
        iwww=iavect+lavect
        lwww=m+2
c 
c       initialize the recursion
c 
        mmm=0
c 
        pols2(1)=1
c 
        mmm=mmm+1
        d=arr(mmm)
        pols2(1)=pols2(1)*d
c 
        done=1
        d34=3*done/4
        d34=sqrt(d34)
c 
        pols2(2)=pols2(1)*z2(2)
        pols2(3)=pols2(1)*(z2(1)*d34-z2(2)/2)
        pols2(4)=pols2(1)*(-z2(1)*d34-z2(2)/2)
c 
        mmm=mmm+1
        call orthmove(arr(mmm),w(ivv),6)
        call ortmatve(w(ivv),pols2(2),2,3,www)
c 
        mmm=mmm+6
        pols2(2)=www(1)
        pols2(3)=www(2)
c 
c       one order after another, construct all the requested
c       orthogonal polynomials of z2
c 
        imm2=1
        imm1=2
c 
        do 3000 m=2,mmax
c 
        imm=imm1+m
c 
        call orevnext(m,pols2(imm2),pols2(imm1),pols2(imm),
     1      z2,arr,mmm,w(ivv),w(iwww),w(iavect) )
c 
        imm2=imm1
        imm1=imm
 3000 continue
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine orevnext(m,pols2mm2,pols2mm1,pols2m,z2,
     1      arr,mmm,vv,www,avect)
        implicit real *8 (a-h,o-z)
        save
        dimension vv(1),pols2mm2(m-1),pols2mm1(m),pols2m(m+1),
     1      z2(2),www(1),arr(1),avect(1)
c 
c        multiply all orthogonal polynomials of the preceding
c        order by the three linear combinations of x, y
c 
        done=1
        d34=3*done/4
        d34=sqrt(d34)
c 
        ii=0
        do 2000 i=1,m
c 
        ii=ii+1
        avect(ii)=pols2mm1(i)*z2(2)
c 
        ii=ii+1
        avect(ii)=pols2mm1(i)*(z2(1)*d34-z2(2)/2)
c 
        ii=ii+1
        avect(ii)=pols2mm1(i)*(-z2(1)*d34-z2(2)/2)
c 
 2000 continue
c 
c       orthogonalize the new polynomials to those in psmm1
c 
        do 2600 i=1,m
c 
        do 2400 j=1,m*3
c 
        mmm=mmm+1
        d=arr(mmm)
        avect(j)=avect(j)-pols2mm1(i)*d
 2400 continue
 2600 continue
c 
c       orthogonalize the new polynomials to those in psmm2
c 
        do 3600 i=1,m-1
c 
        do 3400 j=1,m*3
c 
        mmm=mmm+1
        d=arr(mmm)
        avect(j)=avect(j)-pols2mm2(i)*d
 3400 continue
 3600 continue
c 
        mmm=mmm+1
        jj=(m+1)*m*3
        call orthmove(arr(mmm),vv,jj)
        mmm=mmm+jj
c 
        call ortmatve(vv,avect,m+1,m*3,www)
        do 5200 i=1,m+1
c 
        pols2m(i)=www(i)
 5200 continue
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine orthopol(iw,zs,whts,kk,pols,amatr,eps,mmax,
     1      pols2,uu,vv,itest,arr,mmm,s,mtot)
       implicit real *8 (a-h,o-z)
        save
        dimension zs(2,1),whts(1),pols(kk,1),w(1000 000),
     1      s(200 000),amatr(kk,1),pols2(1),z2(2),uu(kk,1),vv(3,1),
     2      www(10),arr(1)
c 
c       This subroutine constructs orthogonal polynomials on the
c       standard triangle in R^2. MORE IMPORTANTLLY, it constructs
c       the coefficients (returned in the array arr) to be used by
c       the subroutine orthoeva (see) for the evaluation of such
c       orthogonal polynomials at arbitrary points in the standard
c       triangle.
c   PLEASE NOTE THAT THIS IS A VERY CRUDE CODE, SO
C   MUCH SO THAT IT DOES NOT PERFORM ITS OWN MEMORY ALLOCATION.
C   HOWEVER, IT HAS BEEN TESTED FOR N UP TO 40. FURTHERMORE,
C   IT CALCULATES AND STORES ALL VALUES OF ALL POLYNOMIALS OF
C   ALL PRECEDING ORDERS - AN ACT OF EXTREME STUPIDITY. THE ONLY
C   EXCUSE I HAVE IS THAT ONE IS UNLIKELY TO NEED POLINOMIALS OF
C   ORDERS ABOVE 30 OR SO.
c 
c   ALSO, PLEASE NOTE THAT THIS ALGORITHM IS MILDLY UNSTABLE. IN ORDER
C   TO OBTAIN DOUBLE PRECISION ACCURACY, IT SHOULD BE RUN IN EXTENDED
C   RECISION. HOWEVER, ONCE THE COEFFICIENTS IN THE ARRAY ARR HAVE BEEN
C   OBTAINED, THE SUBROUTINE ORTHOEVA CAN (AND SHOULD) BE RUN IN DOUBLE
C   PRECISION.
c 
c       The code also performs a crude test of accuracy of the scheme,
c       by useing the array arr to evaluate all of the created orthogonal
c       polynomials at a single element of array zs (the sequence number
c       of the elemenet to be used for testing is supplied by the user
c       via the parameter itest), and comparing these to the values
c       of the same polynomials obtained via the original recursion).
c 
c                 Input parameters:
c 
c  iw - the FORTRAN unit number on which the output data (arrays arr,
c        s and their lengths) are to be written; they will be read from
c        that unit by one of the subroutines ortretr, ortconv.
c  zs - the nodes at which the standard triangle has been discretized
c  whts - the weights corresponding to the nodes zs
c  kk - the number of nodes in the user-supplied discretization of the
c       standard triangle (in other words, the number of points in the
c       array zs, and the number of weights in the array whts)
c  eps - the accuracy to which the calculations will be performed.
c       Recommended values: 1.0d-13 in double precision, 1.0d-30 in
c       extended precision.
c  mmax - the highest order for which the polynomials will be computed
c  itest - the sequence number of the point in array zs to be used for
c       testing
c 
c                 Output parameters:
c 
c  pols - the values of all orthogonal polynomials of orders up to mmax
c       at all of the nodes of the discretization zs. Nobody will ever
c       use these.
c  pols2 - the values of all orthogonal polynomials at the point
c       (zs(1,itest,zs(2,itest)) - a truly useless parameter
c  arr - the coefficients to be used by the subroutine orthoeva for the
c       evaluation of orthogonal polynomials in the future. Also stored
c       on disk on the FORTRAN unit iw.
c  mmm - the number of elements returned in the array arr
c  s - the singular values obtained by SVDs performed during the
c       construction of orthogonal polynomials - from these, one can see
c       which polynomials of the same order come in pairs
c  mtot - th3 total number of elements returned in array s; also the
c       number of orthogonal polynomials created
c 
c       . . . initialize the recursion
c 
        z2(1)=zs(1,itest)
        z2(2)=zs(2,itest)
c 
        mmm=0
c 
        do 1200 i=1,kk
c 
        pols(i,1)=1
 1200 continue
c 
        pols2(1)=1
c 
        call ortscap(pols(1,1),pols(1,1),whts,kk,d)
c 
        d=1/sqrt(d)
        do 1400 i=1,kk
c 
        pols(i,1)=pols(i,1)*d
 1400 continue
c 
        pols2(1)=pols2(1)*d
c 
        mmm=mmm+1
        arr(mmm)=d
c 
        done=1
        d34=3*done/4
        d34=sqrt(d34)
c 
        do 1600 i=1,kk
c 
        pols(i,2)=pols(i,1)*zs(2,i)
        pols(i,3)=pols(i,1)*(zs(1,i)*d34-zs(2,i)/2)
        pols(i,4)=pols(i,1)*(-zs(1,i)*d34-zs(2,i)/2)
 1600 continue
c 
        pols2(2)=pols2(1)*z2(2)
        pols2(3)=pols2(1)*(z2(1)*d34-z2(2)/2)
        pols2(4)=pols2(1)*(-z2(1)*d34-z2(2)/2)
c 
        do 2000 i=1,3
        do 1800 j=1,kk
c 
        amatr(j,i)=pols(j,i+1)*sqrt(whts(j))
 1800 continue
c 
 2000 continue
c 
  
        lw=1000 000
  
        call svdpivot(ier,amatr,kk,3,uu,vv,s(2),ncols,eps,
     1      w,lw,ltot)
c 
        call prin2('after svdpivot, s=*',s,ncols+1)
c 
        do 2200 i=1,kk
c 
        pols(i,2)=uu(i,1)/sqrt(whts(i))
        pols(i,3)=uu(i,2)/sqrt(whts(i))
 2200 continue
c 
c       post-process the matrix v
c 
        do 2600 i=1,2
        do 2400 j=1,3
c 
        vv(j,i)=vv(j,i)/s(i+1)
 2400 continue
 2600 continue
c 
        call ortmatve(vv,pols2(2),2,3,www)
c 
        mmm=mmm+1
        call orthmove(vv,arr(mmm),6)
c 
        mmm=mmm+6
        pols2(2)=www(1)
        pols2(3)=www(2)
c 
c       one order after another, construct all the requested
c       orthogonal polynomials
c 
        imm2=1
        imm1=2
c 
        do 3000 m=2,mmax
  
        call prinf('m=*',m,1)
c 
        imm=imm1+m
c 
        call orthnext(zs,pols(1,imm2),pols(1,imm1),pols(1,imm),
     1      kk,m,whts,amatr,eps,w,s(imm),uu,vv,
     2      pols2(imm2),pols2(imm1),pols2(imm),z2,itest,arr,mmm)
c 
        imm2=imm1
        imm1=imm
 3000 continue
c 
        mtot=imm1+m-1
  
        call prinf('and mtot=*',mtot,1)
c 
c        store the obtained information on disk, to be used
c        for the evaluation of orthogonal polynomials by the
c        subroutine orthoeva
c 
         if(iw .ne. 0) call ortstore(iw,mmax,mmm,arr,s)
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine orthnext(zs,psmm2,psmm1,psm,kk,m,whts,amatr,
     1      eps,w,s,uu,vv,pols2mm2,pols2mm1,pols2m,z2,itest,
     2      arr,mmm)
        implicit real *8 (a-h,o-z)
        save
        dimension psm(kk,m+1),psmm1(kk,m),psmm2(kk,m-1),
     1      whts(1),amatr(kk,m*3),w(1),zs(2,kk),uu(kk,1),vv(3*m,1),
     2      pols2mm2(m-1),pols2mm1(m),pols2m(m+1),avect(10 000),
     3      z2(2),s(1),www(100),diffs(10 000),arr(1)
  
         call prinf('entered orthnext, m=*',m,1)
c 
c        multiply all orthogonal polynomials of the preceding
c        order by the three linear combinations of x, y
c 
        done=1
        d34=3*done/4
        d34=sqrt(d34)
c 
        ii=0
        do 2000 i=1,m
c 
        ii=ii+1
        do 1200 j=1,kk
c 
        amatr(j,ii)=psmm1(j,i)*zs(2,j)
 1200 continue
c 
        avect(ii)=pols2mm1(i)*z2(2)
c 
        ii=ii+1
        do 1400 j=1,kk
c 
        amatr(j,ii)=psmm1(j,i)*(zs(1,j)*d34-zs(2,j)/2)
 1400 continue
c 
        avect(ii)=pols2mm1(i)*(z2(1)*d34-z2(2)/2)
c 
        ii=ii+1
        do 1600 j=1,kk
c 
        amatr(j,ii)=psmm1(j,i)*(-zs(1,j)*d34-zs(2,j)/2)
 1600 continue
c 
        avect(ii)=pols2mm1(i)*(-z2(1)*d34-z2(2)/2)
c 
 2000 continue
c 
c       orthogonalize the new polynomials to those in psmm1
c 
        do 2600 i=1,m
c 
        do 2400 j=1,m*3
c 
        call ortscap(psmm1(1,i),amatr(1,j),whts,kk,d)
c 
        mmm=mmm+1
        arr(mmm)=d
c 
        do 2200 k=1,kk
c 
        amatr(k,j)=amatr(k,j)-psmm1(k,i)*d
 2200 continue
c 
        avect(j)=avect(j)-pols2mm1(i)*d
 2400 continue
 2600 continue
c 
c       orthogonalize the new polynomials to those in psmm2
c 
  
        do 3600 i=1,m-1
c 
        do 3400 j=1,m*3
c 
        call ortscap(psmm2(1,i),amatr(1,j),whts,kk,d)
c 
        mmm=mmm+1
        arr(mmm)=d
c 
        do 3200 k=1,kk
c 
        amatr(k,j)=amatr(k,j)-psmm2(k,i)*d
 3200 continue
c 
        avect(j)=avect(j)-pols2mm2(i)*d
 3400 continue
 3600 continue
c 
c       construct the SVD of the obtained matrix
c 
        do 4000 i=1,m*3
        do 3800 j=1,kk
c 
        amatr(j,i)=amatr(j,i)*sqrt(whts(j))
 3800 continue
 4000 continue
c 
        lw=1000 000
c 
        call svdpivot(ier,amatr,kk,m*3,uu,vv,s,ncols,eps,
     1      w,lw,ltot)
c 
        call prin2('after svdpivot, s=*',s,ncols)
c 
        do 4400 i=1,m+1
  
        do 4200 j=1,kk
c 
        psm(j,i)=uu(j,i)/sqrt(whts(j))
 4200 continue
c 
 4400 continue
c 
c       post-process the matrix vv
c 
        do 4800 i=1,m*3
        do 4600 j=1,m+1
c 
        vv(i,j)=vv(i,j)/s(j)
 4600 continue
 4800 continue
c 
        call ortmatve(vv,avect,m+1,m*3,www)
c 
        mmm=mmm+1
        jj=(m+1)*m*3
        call orthmove(vv,arr(mmm),jj)
c 
        mmm=mmm+jj
c 
        do 5100 i=1,m+1
c 
        diffs(i)=www(i)-psm(itest,i)
 5100 continue
c 
        call prin2('and diffs=*',diffs,m+1)
c 
        do 5200 i=1,m+1
c 
        pols2m(i)=www(i)
 5200 continue
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine ortstore(iw,mmax,mmm,arr,s)
        implicit real *8 (a-h,o-z)
        save
        dimension arr(mmm),s(1)
c 
c        store on disk the header of this record
c 
        ns=(mmax+1)*(mmax+2)/2
  
 1200 format(3(2x,i6))
        write(iw,1200) mmax,mmm,ns
c 
c       store on disk the array arr of coefficients
c       to be used in the evaluation of orthogonal
c       polynomials on the triangle and the array s
c       of the singular values obtained while generating
c       these coefficients
c 
 1400 format(2x,e23.17,2x,e23.17)
        write(iw,1400) arr
        write(iw,1400)(s(i),i=1,ns)
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine ortretr(ier,ir,mmax,mmm,arr,ns,s)
        implicit real *8 (a-h,o-z)
        save
        dimension arr(1),s(1)
c 
c        read from disk the header of this record
c 
 1200 format(3(2x,i6))
        rewind (ir)
        read(ir,1200) mmax,mmm,ns
c 
c       raed from disk the array arr of coefficients
c       to be used in the evaluation of orthogonal
c       polynomials on the triangle and the array s
c       of the singular values obtained while generating
c       these coefficients
c 
 1400 format(2x,e23.17,2x,e23.17)
        read(ir,1400) (arr(i),i=1,mmm)
        read(ir,1400) (s(i),i=1,ns)
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine ortconv(ier,ir,iw,w)
        implicit real *8 (a-h,o-z)
        save
        dimension w(1)
c 
c        read from disk the header of this record
c 
 1200 format(3(2x,i6))
        rewind (ir)
        read(ir,1200) mmax,mmm,ns
c 
        write(iw) mmax,mmm,ns
c 
c       read from disk the array arr of coefficients
c       to be used in the evaluation of orthogonal
c       polynomials on the triangle and the array s
c       of the singular values obtained while generating
c       these coefficients
c 
 1400 format(2x,e23.17,2x,e23.17)
c 
        read(ir,1400) (w(i),i=1,mmm)
        write(iw) (w(i),i=1,mmm)
c 
        read(ir,1400) (w(i),i=1,ns)
        write(iw) (w(i),i=1,ns)
c 
        return
        end
  
c 
c 
c 
c 
c 
        subroutine ortread(ier,ir,mmax,mmm,arr,ns,s)
        implicit real *8 (a-h,o-z)
        save
        dimension arr(1),s(1)
c 
c        read from disk the header of this record
c 
        rewind(ir)
        read(ir) mmax,mmm,ns
c 
c       read from disk the array arr of coefficients
c       to be used in the evaluation of orthogonal
c       polynomials on the triangle and the array s
c       of the singular values obtained while generating
c       these coefficients
c 
        read(ir) (arr(i),i=1,mmm)
        read(ir) (s(i),i=1,ns)
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine ortscap(x,y,w,n,d)
        implicit real *8 (a-h,o-z)
        save
        dimension x(1),y(1),w(1)
c 
        d=0
        do 2000 i=1,n
        d=d+x(i)*y(i)*w(i)
 2000 continue
        return
        end
c 
c 
c 
c 
c 
        subroutine orthmove(x,y,n)
        implicit real *8 (a-h,o-z)
        save
        dimension x(1),y(1)
c 
        do 1200 i=1,n
        y(i)=x(i)
 1200 continue
        return
        end
c 
c 
c 
c 
c 
        subroutine ortmatve(a,x,n,m,y)
        implicit real *8 (a-h,o-z)
        save
        dimension a(m,n),x(m),y(n)
c 
c        a by x getting y
c 
        do 1400 i=1,n
c 
        d=0
        do 1200 j=1,m
c 
        d=d+a(j,i)*x(j)
 1200 continue
c 
        y(i)=d
 1400 continue
c 
        return
        end

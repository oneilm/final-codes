        implicit real *8 (a-h,o-z)
        dimension w8(1 000 000),zstest(2,100 000),
     1      errs(100 000),boxes(100 000),sides(100 000),
     2      w7(1000 000),z2(10)
c 
        complex *16 fout,derx,dery,fout2,
     1      foutp,foutm,derxp,derxm,deryp,derym,derx2,dery2
  
c 
        external funeval2
c 
        call prini(6,13)
c 
C 
        PRINT *, 'ENTER n'
        READ *,n
        CALL PRINf('n=*',n,1 )
  
c 
c        construct all parameters
c 
        xleft=0
        xright=1
        ybottom=0
        ytop=2
cccc        ytop=1
c 
c        recursively subdivide the user-specified rectangle
c 
        eps=1.0d-12
c 
  
        call prin2('before d2nest_expan0, ytop=*',ytop,1)
  
        lenww=1000 000
  
        iplot=21
  
  
        lenw7=1000 000
        maxboxes=10 000
  
        lenw8=1000 000
  
c         call cd2nest_expan0(ier,xleft,xright,
c     1      ybottom,ytop,n,eps,funeval2,par1,par2,
c     2      boxes,sides,icurr,w7,lenw7,narrays,maxboxes)
  
  
        call cd2nest_expand(ier,xleft,xright,
     1      ybottom,ytop,n,eps,funeval2,par1,par2,iplot,
     2      w8,lenw8,keep,lused)
c 
        call prinf('and ier=*',ier,1)
        call prinf('and keep=*',keep,1)
  
        call prinf('and lused=*',lused,1)
  
c 
c       test the evaluation
c 
        iboxes=w8(1)
        isides=w8(2)
        iw7=w8(3)
  
  
cccc        stop
  
  
        x=0.1
        y=0.1
  
        call cd2nest_eval(ier,x,y,w8,fout,derx,dery)
c 
        call prin2('after cd2nest_eval, fout=*',fout,2)
c 
        z2(1)=x
        z2(2)=y
c 
        call funeval2(z2,fout2,par1,par2)
c 
        call prin2('and fout2=*',fout2,2)
        call prin2('and fout-fout2=*',fout-fout2,2)
c 
c        perform mass testing
c 
        ntest=20
        hx=(xright-xleft)/(ntest-1)
        hy=(ytop-ybottom)/(ntest-1)
  
        call prin2('hx=*',hx,1)
        call prin2('hy=*',hy,1)
        call prin2('ytop=*',ytop,1)
        call prin2('ybottom=*',ybottom,1)
  
  
        iii=0
        do 2400 i=1,ntest
        do 2200 j=1,ntest
c 
        iii=iii+1
c 
        zstest(1,iii)=xleft+(i-1)*hx
        zstest(2,iii)=ybottom+(j-1)*hy
c 
        call cd2nest_eval(ier,zstest(1,iii),zstest(2,iii),w8,
     1      fout,derx,dery)
  
        call funeval2(zstest(1,iii),fout2,par1,par2)
  
        errs(iii)=fout-fout2
  
 2200 continue
 2400 continue
  
        call prin2('and errs=*',errs,iii)
  
  
  
  
c 
c        test the derivatives
c 
        x=0.1
        y=0.1
  
        h=0.00001
  
c 
        call cd2nest_eval(ier,x,y,w8,
     1      fout,derx,dery)
c 
        call cd2nest_eval(ier,x+h,y,w8,
     1      foutp,derxp,deryp)
c 
        call cd2nest_eval(ier,x-h,y,w8,
     1      foutm,derxm,derym)
  
  
        derx2=(foutp-foutm) /h/2
  
        call prin2('and derx=*',derx,1)
        call prin2('and derx2=*',derx2,1)
        call prin2('and derx2-derx=*',derx2-derx,1)
c 
        call cd2nest_eval(ier,x,y+h,w8,
     1      foutp,derxp,deryp)
c 
        call cd2nest_eval(ier,x,y-h,w8,
     1      foutm,derxm,derym)
  
  
  
  
        dery2=(foutp-foutm) /h/2
  
        call prin2('and dery=*',dery,1)
        call prin2('and dery2=*',dery2,1)
        call prin2('and dery2-dery=*',dery2-dery,1)
  
  
  
  
  
        stop
        end
c 
c 
c 
c 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c        This is the end of the debugging code, and the beginning
c        of the code for the construction and evaluation of
c        COMPLEX two-dimensional nested Chebychev expansions
c 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c 
c        This file contains two user-callable subroutines:
c        cd2nest_expand, cd2nest_eval. Following is a brief
c        description of these two subroutines. PLEASE NOTE
C        THAT THESE ARE COMPLEX VERSIONS OF THE SUBROUTINES
C        D2NEST_EXPAND, D2NEST_EVAL (SEE)
c 
c   cd2nest_expand - constructs a nested Chebychev expansion
c        of the user-supplied function in the user-supplied
c        rectangle. The expansion is expected to be subesequently
c        evaluated at arbitrary points within the rectangle via
c        the subroutine d2nest_eval (see).
c 
c   cd2nest_eval - uses the data generated by a preceding
c        call to the subroutine d2nest_expand to (approximately)
c        evaluate the user-supplied function at the user-supplied
c        point in R^2.
c 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c 
c 
c 
        subroutine cd2nest_eval(ier,x,y,w8,fout,derx,dery)
        implicit real *8 (a-h,o-z)
        save
        dimension w8(1)
        complex *16 fout,derx,dery
c 
c 
c        This subroutine uses the data generated by a preceding
c        call to the subroutine cd2nest_expand to (approximately)
c        evaluate the user-supplied COMPLEX function at the
c        user-supplied point in R^2. Please note that this
c        subroutine uses the array w8 generated via a preceding
c        call to cd2nest_expand; neither of these two subroutine
c        has any known uses as a stand-alone device.
c        PLEASE NOTE THAT THIS IS A COMPLEX VERSION OF THE SUBROU-
C        TINE D2NEST_EVAL (SEE).
c 
c                         Input parameters:
c 
c  (x,y) - the point in the plane where the function is to be
c        evaluated
c  w8 - the coefficients of the nested Chebychev expansions (and
c        certain other types of information) created via a prior
c        call to the subroutine d2nest_expand (see)
c 
c                         Output parameters:
c 
c  ier - error return code:
c    ier=0 means successful execution
c    ier=8 means that the user-supplied point (x,y) is outside the
c              rectangle where the function was specified to the
c              subroutine d2nest_expand when the latter was called.
c              This is a fatal error.
c 
c        . . . Check that the user-supplied point is inside the
c              rectangle where the function was specified. If it
c              is outside the specified rectangle, set error return
c              code to 8, and bomb
C 
        xleft=w8(9)
        xright=w8(10)
        ybottom=w8(11)
        ytop=w8(12)
c 
        ier=0
        if( (x .gt. xright) .or. (x .lt. xleft)  .or.
     1      (y .gt. ytop) .or. (y .lt. ybottom) ) then
            ier=8
            return
        endif
c 
        iboxes=w8(1)
        isides=w8(2)
        iw7=w8(3)
        n=w8(5)
        iwork=w8(6)
c 
        call cd2nest_eva0(x,y,w8(iboxes),w8(isides),ii,
     1      w8(iw7),n,fout,derx,dery,w8(iwork))
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_eva0(x,y,boxes,sides,ii,
     1      ww,n,fout,derx,dery,w)
        implicit real *8 (a-h,o-z)
        save
        dimension sides(4,1),w(1)
        complex *16 ww(1),fout,derx,dery
        integer *4 boxes(10,1)
c 
c       find the childless box in which the user-supplied point
c       lives by descending through the quad-three
c 
        ii=1
        do 2000 i=1,200
c 
        if(boxes(4,ii) .eq. -7) goto 2200
c 
c        this box is not childless. find which of its kids
c        the point (x,y) lives in
c 
        centx=(sides(1,ii)+sides(2,ii))/2
        centy=(sides(3,ii)+sides(4,ii))/2
c 
        if( (x .ge. centx) .and. (y .ge. centy) ) then
            jj=4
            goto 1600
        endif
c 
        if( (x .le. centx) .and. (y .ge. centy) ) then
            jj=5
            goto 1600
        endif
c 
        if( (x .le. centx) .and. (y .le. centy) ) then
            jj=6
            goto 1600
        endif
c 
        if( (x .ge. centx) .and. (y .le. centy) ) then
            jj=7
            goto 1600
        endif
c 
 1600 continue
c 
        ii=boxes(jj,ii)
c 
 2000 continue
c 
 2200 continue
c 
c        evaluate the expansion corresponding to the box
c        number ii at the user-supplied point (x,y)
c 
        centx=(sides(1,ii)+sides(2,ii))/2
        centy=(sides(3,ii)+sides(4,ii))/2
c 
        x1=sides(1,ii)
        x2=sides(2,ii)
c 
        ux=2/(x2-x1)
        vx=1-ux*x2
c 
        y1=sides(4,ii)
        y2=sides(3,ii)
c 
        uy=2/(y2-y1)
        vy=1-uy*y2
c 
        xx=ux*x+vx
        yy=uy*y+vy
c 
        j=boxes(8,ii)
c 
        call cch2dev10(ww(j),xx,yy,w(4),w(n+8),
     1      w(2*n+12),w(4*n+16),fout,derx,dery,n)
c 
        derx=derx*ux
        dery=dery*uy
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_expand(ier,xleft,xright,
     1      ybottom,ytop,n,eps,funeval,par1,par2,iplot,
     2      w8,lenw8,keep,lused)
c 
        implicit real *8 (a-h,o-z)
        save
        dimension w8(1)
c 
c        This subroutine constructs a nested Chebychev expansion
c        of the user-supplied COMPLEX function funeval in the
c        user-supplied rectangle. The expansion is expected to be
c        subesequently used via the subroutine d2nest_eval (see).
c        This subroutine has no known uses as a stand-alone device.
c        PLEASE NOTE THAT THIS IS A COMPLEX VERSION OF THE SUBROU-
C        TINE D2NEST_EXPAND (SEE).
c 
c                       Input parameters:
c 
c  xleft - the x-coordinate of the left vertical side of the
c       rectangle to be subdivided
c  xright - the x-coordinate of the right vertical side of the
c       rectangle to be subdivided
c  ybottom - the y-coordinate of the lower horizontal side of the
c       rectangle to be subdivided
c  ytop - the y-coordinate of the upper horizontal side of the
c       rectangle to be subdivided
c  n - the order of the two-dimensional chebychev expansion to be
c       used; the subroutine will place n**2 nodes on the "tensor
c       -product" Chebychev grid on each elementary triangle.
C       PLEASE NOTE THAT N MUST BE EVEN!!!!!
c  eps - the accuracy to which the Chebychev expansions will be
c       calculated.
c    IMPORTANT NOTE ON ACCURACY. PLEASE NOTE THAT THE ACTUAL ACCURACY
C    TENDS TO BE MUCH HIGHER THAN THE USER-SPECIFIED EPS: THE SUBROU-
C    TINE MAKES SURE THAT THE ORDER N/2 CHEBYCHEV EXPANSION ON EACH
C    ELEMENTARY RECTANGLE IS IS ACCURATE (ROUGHLY) TO PRECISION EPS.
C    THE FULL ORDER N EXPANSION TENDS TO BE MUCH MORE ACCURATE.
c 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c  funeval - the function of which the nested Chebychev decomposition
c       is to be constructed. The calling sequence of funeval is
c 
c             funeval(z,f,par1,par2),
c 
c       where
c 
c   z - the point in R^2 at which the function is to be evaluated
c         (input)
c   par1, par2 - any parameters used by the subroutine funeval
c         (integer, real, variable, array, whatever) (input)
c   f - the value of the function at the point z (output)
c 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c  iplot - the identifying number of the file on which the quad-tree
c       constructed by the subroutine will be written in a GNUPLOT-
c       readable for. For example, iplot=21 will cause the output to
c       be written on the files gn21, gn300021. After that, the plot
c       can be produced by "load"ing gn21 into GNUPLOT. Setting
c       iplot=0 will cause the plotting to be suppressed.
c  lenw8 - the amount of space provided to the subroutine in the
c       output/work array w8 (in real *8 locations). Should NEVER be
c       less than 200 000
c 
c                        Output parameters:
c 
c  ier - error return code:
c    ier=0 means successful execution
c    ier=4 means that the subroutine executed successfully but
c       ran out of space in array w8 when it tryed to produce the
c       plot requested by the user. This is NOT a fatal error (no
c       plot will be produced, and who needs it, anyway?). It is
c       an extremely low-probability (maybe, impossible) error.
c    ier=128 - means that the subroutine ran out of space in array
c       w8; this is a fatal error
c    ier=256 - means that the subroutine attempted to create more
c       than 10 000 subrectangles; this is a fatal error.
c  w8 - the coefficients of the nested Chebychev expansions, as
c       well as certain other kinds of information; to be used
c       by the subroutine d2nest_eval in order to (approximately)
c       evaluate the function funeval. The first keep (see below)
c       elements of w8 should not be changed between the call to
c       this subroutine and the subsequent calls to d2nest_eval
c  keep - the number of elements in the array w8 that should not
c       be changed between the call to this subroutine and the
c       subsequent calls to d2nest_eval. Not to be confused with
c       the parameter lused (see below)
c  lused - the the number of elements in the array w8 actually
c       used by the subroutine.
c 
c        . . . allocate memory
c 
        maxboxes=10 000
c 
        iboxes=21
        lboxes=maxboxes*10
c 
        isides=iboxes+lboxes
        lsides=maxboxes*4
c 
        iw7=isides+lsides
        lenw7=lenw8-iw7
c 
        call cd2nest_expan0(ier,xleft,xright,
     1      ybottom,ytop,n,eps,funeval,par1,par2,
     2      w8(iboxes),w8(isides),icurr,w8(iw7),
     3      lenw7,narrays,maxboxes)
c 
        if(ier .ne. 0) return
c 
        lused=iw7+narrays*n**2
c 
c        perform garbage collection
c 
        lboxes2=icurr*10+100
        lsides2=4*icurr+100
c 
        isides2=iboxes+lboxes2+3
        call cd2nest_cpy(w8(isides),w8(isides2),lsides2/2)
        isides=isides2
c 
        iw72=isides+lsides2
        lw72=narrays*n**2*2+100
        call cd2nest_cpy(w8(iw7),w8(iw72),lw72)
        iw7=iw72
c 
        w8(1)=iboxes+0.1
        w8(2)=isides+0.1
        w8(3)=iw7+0.1
        iw8keep=iw7+narrays*n**2*2+10
        w8(4)=iw8keep+0.1
        w8(5)=n+0.1
c 
        iwork=iw8keep+1
        lwork=3*n*2+100
        w8(6)=iwork+0.1
c 
        keep=iwork+lwork
c 
        w8(7)=icurr+0.1
        w8(8)=narrays+0.1
c 
        w8(9)=xleft
        w8(10)=xright
        w8(11)=ybottom
        w8(12)=ytop
c 
c        if the user so requested, plot the obtained structure
c 
        if(iplot .le. 0) return
c 
        lused2=keep+10+5*icurr+100
        if(keep+10+5*icurr+100 .gt. lenw8) then
            ier=4
            return
        endif
c 
        if(lused2 .gt. lused) lused=lused2
c 
        call cd2nest_plot(iplot,w8(isides),icurr,w8(keep+10) )
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_expan0(ier,xleft,xright,
     1      ybottom,ytop,n,eps,funeval,par1,par2,
     2      boxes,sides,icurr,w7,lenw7,narrays,maxboxes)
c 
        implicit real *8 (a-h,o-z)
        save
        dimension sides(4,1),w7(1)
        integer *4 boxes(10,1)
c 
c        allocate memory
c 
        icoefs=21
        lcoefs=n**2*2+100
c 
        ifs=icoefs+lcoefs
        lfs=n**2*2+100
c 
        iz=ifs+lfs
        lz=n**2*2+100
c 
        iw=iz+lz
        lw=2*n**2+6*n+100
c 
        iww=iw+lw
        lenww=lenw7-iww
c 
c       initialize the two-dimensional Chebychev expander
c 
        a=-1
        b=-1
        c=2
        ifinit=1
        call ch2dinit(a,b,c,n,ifinit,w7(iz),w7(iw) )
c 
c       initialize the first column of the arrays boxes, sides
c 
        call cd2nest_iset0(boxes(1,1),10)
c 
        boxes(1,1)=1
        boxes(2,1)=1
        boxes(3,1)=-7
c 
        sides(1,1)=xleft
        sides(2,1)=xright
        sides(3,1)=ybottom
        sides(4,1)=ytop
c 
c        one level after another, subdivide all boxes that need
c        to be subdivided
c 
        narrays=0
        icurr=1
        call cd2nest_iset0(boxes(1,icurr+1),10)
c 
        nzsplot=0
c 
        do 3000 lev=1,20
c 
c        scan all boxes on all levels (for now), subdividing
c        those that need to be subdivided
c 
        icc=icurr
c 
        do 2000 ibox=1,icc
c 
c       if this box has already been processed - skip it
c 
        if(boxes(10,ibox) .eq. 77) goto 2000
c 
c       check if this box needs to be subdivided; subdivide
c       it if it deserves to be subdivided
c 
        if(icurr+5 .gt. maxboxes) then
            ier=256
            return
        endif
c 
        call cd2nest_subdiv1(jer,boxes,sides,ibox,
     1      w7(iw),n,funeval,par1,par2,eps,
     2      icurr,w7(iz),w7(icoefs),w7(ifs),
     3      w7(iww),narrays,lenww)
c 
        if(jer .ne. 0) then
            ier=128
            return
        endif
c 
 2000 continue
c 
c       if no boxes have been subdivided during this pass
c       - exit the loop
c 
        if(icurr .eq. icc) goto 4000
c 
 3000 continue
c 
 4000 continue
c 
        call cd2nest_cpy(w7(iww),w7,narrays*n**2+100)
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_subdiv1(ier,boxes,sides,ibox,
     1      w,n,funeval,par1,par2,eps,
     2      icurr,zs,coefs,fs,ww,narrays,lenww)
c 
        implicit real *8 (a-h,o-z)
        save
  
        dimension zs(2,1),w(1),sides(4,1)
        complex *16 coefs(1),fs(1),ww(1)
  
  
        integer *4 boxes(10,1)
c 
c        This subroutine subdivides (or not) a single box
c 
c                     Input parameters:
c 
c  boxes - the integer (10,*) array containing integer control
c        information for all boxes. Following is a description
c        of all elements in a single column of boxes
c    boxes(1,i) - the sequence number of this box (i.e. will
c      be equal to i)
c    boxes(2,i) - the level of subdivision of this box; please
c      note that the original (unsubdivided) rectangle is on the
c      level 1
c    boxes(3,i) - address in array boxes of the daddy of the box
c      number i; set to -7 for the box number 1 (which, obviously,
c      is an orphan)
c    boxes(4,i), boxes(5,i), boxes(6,i), boxes(7,i) - addresses in
c      array boxes of the four children of the box number i; set
c      to -7 for childless boxes
c    boxes(8,i) - location in the storage array ww of the Chebychev
c      coefficients of the function in the box number i
c    boxes(9,i) - not used at this time
c    boxes(10,i) - set to 0 for boxes that have not been completely
c      processed; ste to 77 for boxes that need not be looked at
c      any more.
c 
c        . . . check if this box needs to be subdivided
c 
        ier=0
c 
        lev=boxes(2,ibox)
        xleft=sides(1,ibox)
        xright=sides(2,ibox)
        ybottom=sides(3,ibox)
        ytop=sides(4,ibox)
c 
        call cd2nest_ifdivide(xleft,xright,
     1      ybottom,ytop,zs,n,w,funeval,par1,par2,eps,
     2      ifdivide,coefs,fs)
c 
c        if this box does not need to be subdivided - enter
c        this fact on the array boxes, and exit
c 
        if(ifdivide .eq. 1) goto 2000
c 
        boxes(4,ibox)=-7
        boxes(5,ibox)=-7
        boxes(6,ibox)=-7
        boxes(7,ibox)=-7
        boxes(10,ibox)=77
c 
        iarr=narrays*n**2+1
c 
        ltot=iarr+n**2+10
c 
        if(ltot .gt. lenww) then
            ier=128
            return
        endif
c 
        call cd2nest_cpy(coefs,ww(iarr),n**2*2)
  
  
        boxes(8,ibox)=iarr
        narrays=narrays+1
c 
        return
c 
 2000 continue
c 
c       this box needs to be subdivided. act accordingly
c 
        call cd2nest_divide(xleft,xright,
     1      ybottom,ytop,
     2      x1left,x1right,y1bottom,y1top,
     3      x2left,x2right,y2bottom,y2top,
     4      x3left,x3right,y3bottom,y3top,
     5      x4left,x4right,y4bottom,y4top)
c 
c       store the data abouth the first sonny
c 
        icurr=icurr+1
        ison1=icurr
        levson=lev+1
c 
        boxes(1,ison1)=ison1
        boxes(2,ison1)=levson
        boxes(3,ison1)=ibox
c 
        sides(1,ison1)=x1left
        sides(2,ison1)=x1right
        sides(3,ison1)=y1bottom
        sides(4,ison1)=y1top
c 
c       store the data about the second sonny
c 
        icurr=icurr+1
        ison2=icurr
        levson=lev+1
c 
        boxes(1,ison2)=ison2
        boxes(2,ison2)=levson
        boxes(3,ison2)=ibox
c 
        sides(1,ison2)=x2left
        sides(2,ison2)=x2right
        sides(3,ison2)=y2bottom
        sides(4,ison2)=y2top
c 
c       store the data about the third sonny
c 
        icurr=icurr+1
        ison3=icurr
        levson=lev+1
c 
        boxes(1,ison3)=ison3
        boxes(2,ison3)=levson
        boxes(3,ison3)=ibox
c 
        sides(1,ison3)=x3left
        sides(2,ison3)=x3right
        sides(3,ison3)=y3bottom
        sides(4,ison3)=y3top
c 
c       store the data about the fourth sonny
c 
        icurr=icurr+1
        ison4=icurr
        levson=lev+1
c 
        boxes(1,ison4)=ison4
        boxes(2,ison4)=levson
        boxes(3,ison4)=ibox
c 
        sides(1,ison4)=x4left
        sides(2,ison4)=x4right
        sides(3,ison4)=y4bottom
        sides(4,ison4)=y4top
c 
c       store the relevant data in the column ibox of array boxes
c 
        boxes(4,ibox)=ison1
        boxes(5,ibox)=ison2
        boxes(6,ibox)=ison3
        boxes(7,ibox)=ison4
c 
        boxes(10,ibox)=77
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_iset0(iarr,n)
        implicit real *8 (a-h,o-z)
        save
        dimension iarr(n),a(1),b(1)
c 
        do 1200 i=1,n
c 
        iarr(i)=0
 1200 continue
        return
c 
c 
c 
c 
        entry cd2nest_cpy(a,b,n)
c 
        do 2200 i=1,n*2
        b(i)=a(i)
 2200 continue
        return
        end
c 
c 
c 
c 
c 
        subroutine funeval2(z,f,par1,par2)
        implicit real *8 (a-h,o-z)
        save
        dimension z(2)
        complex *16 f,ima
        data ima/(0.0d0,1.0d0)/
c 
        f=z(1)**2+z(2)**6
  
        f=sin(z(1))+cos(z(2)) +log(z(1)**2+z(2)**2+0.01)*ima
  
         return
         end
c 
c 
c 
c 
c 
        subroutine cd2nest_ifdivide(xleft,xright,
     1      ybottom,ytop,zs,n,w,funeval,par1,par2,eps,
     2      ifdivide,coefs,fs)
        implicit real *8 (a-h,o-z)
        save
        dimension zs(2,1),w(1)
        complex *16 fs(1),coefs(n,n)
c 
c        construct the nodes discretizing this rectangle
c 
        call cd2nest_discr(xleft,xright,
     1      ybottom,ytop,w,n,zs)
c 
c        construct the array of values of the function to be
c        expanded on the suspect rectangle
c 
         d=0
c 
         do 1400 i=1,n**2
c 
         call funeval(zs(1,i),fs(i),par1,par2)
c 
         d=d+fs(i)*conjg(fs(i))
 1400 continue
c 
         dnorm=sqrt(d)
c 
c        construct the decomposition of the obtained function
c 
         call cch2dexp(fs,n,coefs,w)
  
cccc         call prin2('in cd2nest_ifdivide, coefs=*',coefs,n*n*2)
  
  
c 
c        scan the coefficients coefs(i,j) corresponding to i > n/2 or
c        j > n/2, to see if any of them things are greater than eps
c 
        dmax=0
        do 1800 i=n/2+1,n
        do 1600 j=1,n
c 
        d=abs(coefs(j,i))
        if(dmax .lt. d) dmax=d
 1600 continue
 1800 continue
c 
        do 2800 i=n/2+1,n
        do 2600 j=1,n
c 
        d=abs(coefs(i,j))
        if(dmax .lt. d) dmax=d
 2600 continue
 2800 continue
c 
        call prin2('and dmax=*',dmax,1)
c 
        ifdivide=0
        if(dmax .gt. eps*dnorm) ifdivide=1
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_discr(xleft,xright,
     1      ybottom,ytop,w,n,z)
c 
        implicit real *8 (a-h,o-z)
        save
        dimension z(2,1),w(1)
c 
c        discretize the rectangle
c 
        ifinit=0
        a=-1
        b=-1
        c=2
c 
        call ch2dinit(a,b,c,n,ifinit,z,w)
c 
        alphax=(xright-xleft)/2
        betax=(xright+xleft)/2
c 
        alphay=(ybottom-ytop)/2
        betay=(ybottom+ytop)/2
c 
        do 1200 i=1,n**2
c 
        z(1,i)=alphax*z(1,i)+betax
        z(2,i)=alphay*z(2,i)+betay
 1200 continue
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_divide(xleft,xright,
     1      ybottom,ytop,
     2      x1left,x1right,y1bottom,y1top,
     3      x2left,x2right,y2bottom,y2top,
     4      x3left,x3right,y3bottom,y3top,
     5      x4left,x4right,y4bottom,y4top)
c 
        implicit real *8 (a-h,o-z)
c 
c       This subroutine subdivides a user-provided rectangle
c       (orieneted in the standard manner with respect to the
c       system of coordinates) into 4 rectangles of half the
c       size and the same shape.
c 
c                    Input parameters:
c 
c  xleft - the x-coordinate of the left vertical side of the
c       rectangle to be subdivided
c  xright - the x-coordinate of the right vertical side of the
c       rectangle to be subdivided
c  ybottom - the y-coordinate of the lower horizontal side of the
c       rectangle to be subdivided
c  ytop - the y-coordinate of the upper horizontal side of the
c       rectangle to be subdivided
c 
c                    Output parameters:
c 
c  x1left, x1right - the x-coordinates of the left and right vertical
c       sides respectively of the first sonny
c  y1bottom, y1top - the y-coordinates of the bottom and top horizontal
c       sides respectively of the first sonny
c  x2left, x2right - the x-coordinates of the left and right vertical
c       sides respectively of the second sonny
c  y2bottom, y2top - the y-coordinates of the bottom and top horizontal
c       sides respectively of the second sonny
c  x3left, x3right - the x-coordinates of the left and right vertical
c       sides respectively of the third sonny
c  y3bottom, y3top - the y-coordinates of the bottom and top horizontal
c       sides respectively of the third sonny
c  x4left, x4right - the x-coordinates of the left and right vertical
c       sides respectively of the fourth sonny
c  y4bottom, y4top - the y-coordinates of the bottom and top horizontal
c       sides respectively of the fourth sonny
c 
c        . . . subdivide the user-supplied rectangle
c              into 4 smaller ones
c 
        save
        x1left=(xleft+xright)/2
        x1right=xright
        y1bottom=(ybottom+ytop)/2
        y1top=ytop
c 
        x2left=xleft
        x2right=(xleft+xright)/2
        y2bottom=(ybottom+ytop)/2
        y2top=ytop
c 
        x3left=xleft
        x3right=(xleft+xright)/2
        y3top=(ybottom+ytop)/2
        y3bottom=ybottom
c 
        x4left=(xleft+xright)/2
        x4right=xright
        y4top=(ybottom+ytop)/2
        y4bottom=ybottom
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine cd2nest_plot(iw,sides,icurr,w)
        implicit real *8 (a-h,o-z)
        save
        dimension sides(4,1),w(1)
c 
c       scan all boxes; store the outlines of the ones with
c       children, and both the outlines and the contents of the
c       childless ones
c 
        call trplopen(w)
c 
        do 2000 i=1,icurr
c 
        xx1=sides(1,i)
        xx2=sides(2,i)
        yy1=sides(3,i)
        yy2=sides(4,i)
c 
        x1=xx1
        y1=yy1
c 
        x2=xx2
        y2=yy1
c 
        x3=xx2
        y3=yy2
c 
        x4=xx1
        y4=yy2
c 
        call trplline(x1,y1,x2,y2,w)
        call trplline(x2,y2,x3,y3,w)
        call trplline(x3,y3,x4,y4,w)
        call trplline(x4,y4,x1,y1,w)
c 
 2000 continue
c 
        call trplwrt(iw,w,'boxes*')
c 
        return
        end
